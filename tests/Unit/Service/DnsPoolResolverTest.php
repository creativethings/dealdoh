<?php declare(strict_types=1);

namespace NoGlitchYo\Dealdoh\Tests\Unit\Service;

use Exception;
use Mockery;
use Mockery\MockInterface;
use NoGlitchYo\Dealdoh\Client\DnsClientInterface;
use NoGlitchYo\Dealdoh\Service\DnsPoolResolver;
use NoGlitchYo\Dealdoh\Entity\DnsUpstream;
use NoGlitchYo\Dealdoh\Entity\DnsUpstreamPool;
use NoGlitchYo\Dealdoh\Exception\DnsPoolResolveFailedException;
use NoGlitchYo\Dealdoh\Exception\UpstreamNotSupportedException;
use NoGlitchYo\Dealdoh\Entity\Dns\Message;
use NoGlitchYo\Dealdoh\Entity\Dns\Message\Header;
use NoGlitchYo\Dealdoh\Entity\Dns\Message\HeaderInterface;
use PHPUnit\Framework\TestCase;

/**
 * @covers \NoGlitchYo\Dealdoh\Service\DnsPoolResolver
 */
class DnsPoolResolverTest extends TestCase
{
    use Mockery\Adapter\Phpunit\MockeryPHPUnitIntegration;

    /**
     * @var DnsClientInterface[]|MockInterface[]
     */
    private $dnsClientsMock;

    /**
     * @var DnsUpstreamPool|MockInterface
     */
    private $dnsUpstreamPoolMock;

    /** @var \NoGlitchYo\Dealdoh\Service\DnsPoolResolver */
    private $sut;

    protected function setUp(): void
    {
        $this->dnsUpstreamPoolMock = Mockery::mock(DnsUpstreamPool::class);
        $this->dnsClientsMock = [
            Mockery::mock(DnsClientInterface::class),
        ];

        $this->sut = new DnsPoolResolver($this->dnsUpstreamPoolMock, $this->dnsClientsMock);

        parent::setUp(); // TODO: Change the autogenerated stub
    }

    public function testResolveStopAndReturnResponseIfClientSucceedToResolveWithUpstream()
    {
        $upstream1 = new DnsUpstream('localhost:53');
        $upstream2 = new DnsUpstream('https://cloudflare-dns.com/dns-query');
        $dnsRequestMessageMock = new Message(
            new Header(0, false, 0, false, false, true, false, 0, HeaderInterface::RCODE_OK)
        );
        $dnsResponseMessage = new Message(
            new Header(0, true, 0, false, false, true, false, 0, HeaderInterface::RCODE_OK)
        );

        $this->dnsUpstreamPoolMock
            ->shouldReceive('getUpstreams')
            ->andReturn([$upstream1, $upstream2]);

        $this->dnsClientsMock[0]
            ->shouldReceive('supports')
            ->with($upstream1)
            ->andReturn(true);

        $this->dnsClientsMock[0]
            ->shouldNotReceive('supports')
            ->with($upstream2);

        $this->dnsClientsMock[0]
            ->shouldReceive('resolve')
            ->with($upstream1, $dnsRequestMessageMock)
            ->andReturn($dnsResponseMessage);

        $this->dnsClientsMock[0]
            ->shouldNotReceive('resolve')
            ->with($upstream2, $dnsRequestMessageMock);

        $this->assertEquals($dnsResponseMessage, $this->sut->resolve($dnsRequestMessageMock));
    }

    public function testResolveRetryWithNextUpstreamIfNxdomainResponse()
    {
        $upstream1 = new DnsUpstream('localhost:53');
        $upstream2 = new DnsUpstream('https://cloudflare-dns.com/dns-query');
        $upstream3 = new DnsUpstream('8.8.8.8:53');
        $dnsRequestMessage = new Message(
            new Header(0, false, 0, false, false, true, false, 0, HeaderInterface::RCODE_OK)
        );
        $dnsResponseMessageOk = new Message(
            new Header(0, true, 0, false, false, true, false, 0, HeaderInterface::RCODE_OK)
        );
        $dnsResponseMessageRefused = new Message(
            new Header(0, true, 0, false, false, true, false, 0, HeaderInterface::RCODE_NAME_ERROR)
        );

        $this->dnsUpstreamPoolMock
            ->shouldReceive('getUpstreams')
            ->andReturn([$upstream1, $upstream2, $upstream3]);

        $this->dnsClientsMock[0]
            ->shouldReceive('supports')
            ->with($upstream1)
            ->andReturn(true);

        $this->dnsClientsMock[0]
            ->shouldReceive('supports')
            ->with($upstream2)
            ->andReturn(true);

        $this->dnsClientsMock[0]
            ->shouldNotReceive('supports')
            ->with($upstream3);

        $this->dnsClientsMock[0]
            ->shouldReceive('resolve')
            ->with($upstream1, $dnsRequestMessage)
            ->andReturn($dnsResponseMessageRefused);

        $this->dnsClientsMock[0]
            ->shouldReceive('resolve')
            ->with($upstream2, $dnsRequestMessage)
            ->andReturn($dnsResponseMessageOk);

        $this->assertEquals($dnsResponseMessageOk, $this->sut->resolve($dnsRequestMessage));
    }


    public function testResolveRetryWithNextUpstreamIfClientFailedToResolve()
    {
        $upstream1 = new DnsUpstream('localhost:53');
        $upstream2 = new DnsUpstream('https://cloudflare-dns.com/dns-query');
        $dnsRequestMessage = new Message(
            new Header(0, false, 0, false, false, true, false, 0, HeaderInterface::RCODE_OK)
        );
        $dnsResponseMessage = new Message(
            new Header(0, true, 0, false, false, true, false, 0, HeaderInterface::RCODE_OK)
        );

        $this->dnsUpstreamPoolMock
            ->shouldReceive('getUpstreams')
            ->andReturn([$upstream1, $upstream2]);

        $this->dnsClientsMock[0]
            ->shouldReceive('supports')
            ->with($upstream1)
            ->andReturn(true);

        $this->dnsClientsMock[0]
            ->shouldReceive('supports')
            ->with($upstream2)
            ->andReturn(true);

        $this->dnsClientsMock[0]
            ->shouldReceive('resolve')
            ->with($upstream1, $dnsRequestMessage)
            ->andThrow(Exception::class);

        $this->dnsClientsMock[0]
            ->shouldReceive('resolve')
            ->with($upstream2, $dnsRequestMessage)
            ->andReturn($dnsResponseMessage);

        $this->assertEquals($dnsResponseMessage, $this->sut->resolve($dnsRequestMessage));
    }

    public function testResolveThrowExceptionIfNoClientCanHandleUpstream()
    {
        $upstream1 = new DnsUpstream('localhost:53');
        $dnsRequestMessage = new Message(
            new Header(0, false, 0, false, false, true, false, 0, HeaderInterface::RCODE_OK)
        );

        $this->dnsUpstreamPoolMock
            ->shouldReceive('getUpstreams')
            ->andReturn([$upstream1]);

        $this->dnsClientsMock[0]
            ->shouldReceive('supports')
            ->with($upstream1)
            ->andReturn(false);

        $this->expectException(UpstreamNotSupportedException::class);

        $this->sut->resolve($dnsRequestMessage);
    }


    public function testResolveThrowExceptionIfFailedToResolveAfterTryingWithEveryUpstream()
    {
        $upstream1 = new DnsUpstream('localhost:53');
        $upstream2 = new DnsUpstream('https://cloudflare-dns.com/dns-query');
        $dnsRequestMessage = new Message(
            new Header(0, false, 0, false, false, true, false, 0, HeaderInterface::RCODE_OK)
        );

        $this->dnsUpstreamPoolMock
            ->shouldReceive('getUpstreams')
            ->andReturn([$upstream1, $upstream2]);

        $this->dnsClientsMock[0]
            ->shouldReceive('supports')
            ->with($upstream1)
            ->andReturn(true);

        $this->dnsClientsMock[0]
            ->shouldReceive('supports')
            ->with($upstream2)
            ->andReturn(true);

        $this->dnsClientsMock[0]
            ->shouldReceive('resolve')
            ->with($upstream1, $dnsRequestMessage)
            ->andThrow(Exception::class);

        $this->dnsClientsMock[0]
            ->shouldReceive('resolve')
            ->with($upstream2, $dnsRequestMessage)
            ->andThrow(Exception::class);

        $this->expectException(DnsPoolResolveFailedException::class);

        $this->sut->resolve($dnsRequestMessage);
    }
}
